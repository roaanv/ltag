#!/usr/bin/env node
(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/commander/index.js":
/*!*****************************************!*\
  !*** ./node_modules/commander/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nconst spawn = __webpack_require__(/*! child_process */ \"child_process\").spawn;\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\n// @ts-check\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} description\n   * @api public\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = _parseOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.description = description || '';\n    this.defaultValue = undefined;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  };\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  };\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  };\n}\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   * @api public\n   */\n\n  constructor(name) {\n    super();\n    this.commands = [];\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._args = [];\n    this.rawArgs = null;\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._storeOptionsAsProperties = true; // backwards compatible by default\n    this._storeOptionsAsPropertiesCalled = false;\n    this._passCommandToAction = true; // backwards compatible by default\n    this._actionResults = [];\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._hasImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * Examples:\n   *\n   *      // Command implemented using action handler (description is supplied separately to `.command`)\n   *      program\n   *        .command('clone <source> [destination]')\n   *        .description('clone a repository into a newly created directory')\n   *        .action((source, destination) => {\n   *          console.log('clone command called');\n   *        });\n   *\n   *      // Command implemented using separate executable file (description is second parameter to `.command`)\n   *      program\n   *        .command('start <service>', 'start named service')\n   *        .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   * @api public\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const args = nameAndArgs.split(/ +/);\n    const cmd = this.createCommand(args.shift());\n\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n\n    cmd._hidden = !!(opts.noHelp || opts.hidden);\n    cmd._hasHelpOption = this._hasHelpOption;\n    cmd._helpFlags = this._helpFlags;\n    cmd._helpDescription = this._helpDescription;\n    cmd._helpShortFlag = this._helpShortFlag;\n    cmd._helpLongFlag = this._helpLongFlag;\n    cmd._helpCommandName = this._helpCommandName;\n    cmd._helpCommandnameAndArgs = this._helpCommandnameAndArgs;\n    cmd._helpCommandDescription = this._helpCommandDescription;\n    cmd._exitCallback = this._exitCallback;\n    cmd._storeOptionsAsProperties = this._storeOptionsAsProperties;\n    cmd._passCommandToAction = this._passCommandToAction;\n    cmd._combineFlagAndOptionalValue = this._combineFlagAndOptionalValue;\n\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    this.commands.push(cmd);\n    cmd._parseExpectedArgs(args);\n    cmd.parent = this;\n\n    if (desc) return this;\n    return cmd;\n  };\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   * @api public\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  };\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   * @api public\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');\n\n    // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach((cmd) => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n        checkExplicitNames(cmd.commands);\n      });\n    }\n    checkExplicitNames(cmd.commands);\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  };\n\n  /**\n   * Define argument syntax for the command.\n   *\n   * @api public\n   */\n\n  arguments(desc) {\n    return this._parseExpectedArgs(desc.split(/ +/));\n  };\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   * @api public\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._hasImplicitHelpCommand = false;\n    } else {\n      this._hasImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  };\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _lazyHasImplicitHelpCommand() {\n    if (this._hasImplicitHelpCommand === undefined) {\n      this._hasImplicitHelpCommand = this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._hasImplicitHelpCommand;\n  };\n\n  /**\n   * Parse expected `args`.\n   *\n   * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n   *\n   * @param {Array} args\n   * @return {Command} `this` command for chaining\n   * @api private\n   */\n\n  _parseExpectedArgs(args) {\n    if (!args.length) return;\n    args.forEach((arg) => {\n      const argDetails = {\n        required: false,\n        name: '',\n        variadic: false\n      };\n\n      switch (arg[0]) {\n        case '<':\n          argDetails.required = true;\n          argDetails.name = arg.slice(1, -1);\n          break;\n        case '[':\n          argDetails.name = arg.slice(1, -1);\n          break;\n      }\n\n      if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {\n        argDetails.variadic = true;\n        argDetails.name = argDetails.name.slice(0, -3);\n      }\n      if (argDetails.name) {\n        this._args.push(argDetails);\n      }\n    });\n    this._args.forEach((arg, i) => {\n      if (arg.variadic && i < this._args.length - 1) {\n        throw new Error(`only the last argument can be variadic '${arg.name}'`);\n      }\n    });\n    return this;\n  };\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   * @api public\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  };\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * Examples:\n   *\n   *      program\n   *        .command('help')\n   *        .description('display verbose help')\n   *        .action(function() {\n   *           // output help here\n   *        });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   * @api public\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._passCommandToAction) {\n        actionArgs[expectedArgsCount] = this;\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      // Add the extra arguments so available too.\n      if (args.length > expectedArgsCount) {\n        actionArgs.push(args.slice(expectedArgsCount));\n      }\n\n      const actionResult = fn.apply(this, actionArgs);\n      // Remember result in case it is async. Assume parseAsync getting called on root.\n      let rootCommand = this;\n      while (rootCommand.parent) {\n        rootCommand = rootCommand.parent;\n      }\n      rootCommand._actionResults.push(actionResult);\n    };\n    this._actionHandler = listener;\n    return this;\n  };\n\n  /**\n   * Internal routine to check whether there is a clash storing option value with a Command property.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  _checkForOptionNameClash(option) {\n    if (!this._storeOptionsAsProperties || this._storeOptionsAsPropertiesCalled) {\n      // Storing options safely, or user has been explicit and up to them.\n      return;\n    }\n    // User may override help, and hard to tell if worth warning.\n    if (option.name() === 'help') {\n      return;\n    }\n\n    const commandProperty = this._getOptionValue(option.attributeName());\n    if (commandProperty === undefined) {\n      // no clash\n      return;\n    }\n\n    let foundClash = true;\n    if (option.negate) {\n      // It is ok if define foo before --no-foo.\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      foundClash = !this._findOption(positiveLongFlag);\n    } else if (option.long) {\n      const negativeLongFlag = option.long.replace(/^--/, '--no-');\n      foundClash = !this._findOption(negativeLongFlag);\n    }\n\n    if (foundClash) {\n      throw new Error(`option '${option.name()}' clashes with existing property '${option.attributeName()}' on Command\n- call storeOptionsAsProperties(false) to store option values safely,\n- or call storeOptionsAsProperties(true) to suppress this check,\n- or change option name\n\nRead more on https://git.io/JJc0W`);\n    }\n  };\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @param {Object} config\n   * @param {string} flags\n   * @param {string} description\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   * @api private\n   */\n\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = new Option(flags, description);\n    const oname = option.name();\n    const name = option.attributeName();\n    option.mandatory = !!config.mandatory;\n\n    this._checkForOptionNameClash(option);\n\n    // default as 3rd arg\n    if (typeof fn !== 'function') {\n      if (fn instanceof RegExp) {\n        // This is a bit simplistic (especially no error messages), and probably better handled by caller using custom option processing.\n        // No longer documented in README, but still present for backwards compatibility.\n        const regex = fn;\n        fn = (val, def) => {\n          const m = regex.exec(val);\n          return m ? m[0] : def;\n        };\n      } else {\n        defaultValue = fn;\n        fn = null;\n      }\n    }\n\n    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this._getOptionValue(name) : true;\n      }\n      // preassign only if we have a default\n      if (defaultValue !== undefined) {\n        this._setOptionValue(name, defaultValue);\n        option.defaultValue = defaultValue;\n      }\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // when it's passed assign the value\n    // and conditionally invoke the callback\n    this.on('option:' + oname, (val) => {\n      const oldValue = this._getOptionValue(name);\n\n      // custom processing\n      if (val !== null && fn) {\n        val = fn(val, oldValue === undefined ? defaultValue : oldValue);\n      } else if (val !== null && option.variadic) {\n        if (oldValue === defaultValue || !Array.isArray(oldValue)) {\n          val = [val];\n        } else {\n          val = oldValue.concat(val);\n        }\n      }\n\n      // unassigned or boolean value\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this._setOptionValue(name, option.negate\n            ? false\n            : defaultValue || true);\n        } else {\n          this._setOptionValue(name, val);\n        }\n      } else if (val !== null) {\n        // reassign\n        this._setOptionValue(name, option.negate ? false : val);\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string should contain both the short and long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *    \"-p, --pepper\"\n   *    \"-p|--pepper\"\n   *    \"-p --pepper\"\n   *\n   * Examples:\n   *\n   *     // simple boolean defaulting to undefined\n   *     program.option('-p, --pepper', 'add pepper');\n   *\n   *     program.pepper\n   *     // => undefined\n   *\n   *     --pepper\n   *     program.pepper\n   *     // => true\n   *\n   *     // simple boolean defaulting to true (unless non-negated option is also defined)\n   *     program.option('-C, --no-cheese', 'remove cheese');\n   *\n   *     program.cheese\n   *     // => true\n   *\n   *     --no-cheese\n   *     program.cheese\n   *     // => false\n   *\n   *     // required argument\n   *     program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   *     --chdir /tmp\n   *     program.chdir\n   *     // => \"/tmp\"\n   *\n   *     // optional argument\n   *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} description\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   * @api public\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  };\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string should contain both the short and long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} description\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  * @api public\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  };\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * Examples:\n   *\n   *    // for `.option('-f,--flag [value]'):\n   *    .combineFlagAndOptionalValue(true)  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   *    .combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [arg] - if `true` or omitted, an optional value can be specified directly after the flag.\n   * @api public\n   */\n  combineFlagAndOptionalValue(arg) {\n    this._combineFlagAndOptionalValue = (arg === undefined) || arg;\n    return this;\n  };\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [arg] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   * @api public\n   */\n  allowUnknownOption(arg) {\n    this._allowUnknownOption = (arg === undefined) || arg;\n    return this;\n  };\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} value\n    * @return {Command} `this` command for chaining\n    * @api public\n    */\n\n  storeOptionsAsProperties(value) {\n    this._storeOptionsAsPropertiesCalled = true;\n    this._storeOptionsAsProperties = (value === undefined) || value;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  };\n\n  /**\n    * Whether to pass command to action handler,\n    * or just the options (specify false).\n    *\n    * @param {boolean} value\n    * @return {Command} `this` command for chaining\n    * @api public\n    */\n\n  passCommandToAction(value) {\n    this._passCommandToAction = (value === undefined) || value;\n    return this;\n  };\n\n  /**\n   * Store option value\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @api private\n   */\n\n  _setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n  };\n\n  /**\n   * Retrieve option value\n   *\n   * @param {string} key\n   * @return {Object} value\n   * @api private\n   */\n\n  _getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parse(process.argv);\n   *      program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   * @api public\n   */\n\n  parse(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n    if (!this._scriptPath && process.mainModule) {\n      this._scriptPath = process.mainModule.filename;\n    }\n\n    // Guess name, used in usage in help.\n    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));\n\n    // Let's go!\n    this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parseAsync(process.argv);\n   *      program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   * @api public\n   */\n\n  parseAsync(argv, parseOptions) {\n    this.parse(argv, parseOptions);\n    return Promise.all(this._actionResults).then(() => this);\n  };\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.mjs'];\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n\n    // Want the entry script as the reference for command name and directory for searching for other files.\n    let scriptPath = this._scriptPath;\n    // Fallback in case not set, due to how Command created or called.\n    if (!scriptPath && process.mainModule) {\n      scriptPath = process.mainModule.filename;\n    }\n\n    let baseDir;\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    }\n\n    // name of the subcommand, like `pm-install`\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach((ext) => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n    launchWithNode = sourceExt.includes(path.extname(bin));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = spawn(bin, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach((signal) => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    });\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  };\n\n  /**\n   * @api private\n   */\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this._helpAndError();\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      subCommand._parseCommand(operands, unknown);\n    }\n  };\n\n  /**\n   * Process arguments in context of this command.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    } else if (this._lazyHasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      } else {\n        this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n      }\n    } else if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    } else {\n      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n        // probably missing subcommand and no handler, user needs help\n        this._helpAndError();\n      }\n\n      outputHelpIfRequested(this, parsed.unknown);\n      this._checkForMissingMandatoryOptions();\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n\n      if (this._actionHandler) {\n        const args = this.args.slice();\n        this._args.forEach((arg, i) => {\n          if (arg.required && args[i] == null) {\n            this.missingArgument(arg.name);\n          } else if (arg.variadic) {\n            args[i] = args.splice(i);\n          }\n        });\n\n        this._actionHandler(args);\n        this.emit('command:' + this.name(), operands, unknown);\n      } else if (operands.length) {\n        if (this._findCommand('*')) {\n          this._dispatchSubcommand('*', operands, unknown);\n        } else if (this.listenerCount('command:*')) {\n          this.emit('command:*', operands, unknown);\n        } else if (this.commands.length) {\n          this.unknownCommand();\n        }\n      } else if (this.commands.length) {\n        // This command has subcommands and nothing hooked up at this level, so display help.\n        this._helpAndError();\n      } else {\n        // fall through for caller to handle after calling .parse()\n      }\n    }\n  };\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  };\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  };\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd._getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  };\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *    argv => operands, unknown\n   *    --known kkk op => [op], []\n   *    op --known kkk => [op], []\n   *    sub --unknown uuu op => [sub], [--unknown uuu op]\n   *    sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   * @api public\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // looks like an option but unknown, unknowns from here\n      if (arg.length > 1 && arg[0] === '-') {\n        dest = unknown;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  };\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   * @api public\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  };\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    console.error(message);\n    this._exit(1, 'commander.missingArgument', message);\n  };\n\n  /**\n   * `Option` is missing an argument, but received `flag` or nothing.\n   *\n   * @param {Option} option\n   * @param {string} [flag]\n   * @api private\n   */\n\n  optionMissingArgument(option, flag) {\n    let message;\n    if (flag) {\n      message = `error: option '${option.flags}' argument missing, got '${flag}'`;\n    } else {\n      message = `error: option '${option.flags}' argument missing`;\n    }\n    console.error(message);\n    this._exit(1, 'commander.optionMissingArgument', message);\n  };\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    console.error(message);\n    this._exit(1, 'commander.missingMandatoryOptionValue', message);\n  };\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    const message = `error: unknown option '${flag}'`;\n    console.error(message);\n    this._exit(1, 'commander.unknownOption', message);\n  };\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const partCommands = [this.name()];\n    for (let parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {\n      partCommands.unshift(parentCmd.name());\n    }\n    const fullCommand = partCommands.join(' ');\n    const message = `error: unknown command '${this.args[0]}'.` +\n      (this._hasHelpOption ? ` See '${fullCommand} ${this._helpLongFlag}'.` : '');\n    console.error(message);\n    this._exit(1, 'commander.unknownCommand', message);\n  };\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   * @api public\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = new Option(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      process.stdout.write(str + '\\n');\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  };\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} str\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   * @api public\n   */\n\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    this._argsDescription = argsDescription;\n    return this;\n  };\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   * @api public\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  };\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   * @api public\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  };\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   * @api public\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  };\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   * @api public\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  };\n\n  /**\n   * Return prepared commands.\n   *\n   * @return {Array}\n   * @api private\n   */\n\n  prepareCommands() {\n    const commandDetails = this.commands.filter((cmd) => {\n      return !cmd._hidden;\n    }).map((cmd) => {\n      const args = cmd._args.map((arg) => {\n        return humanReadableArgName(arg);\n      }).join(' ');\n\n      return [\n        cmd._name +\n          (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n          (cmd.options.length ? ' [options]' : '') +\n          (args ? ' ' + args : ''),\n        cmd._description\n      ];\n    });\n\n    if (this._lazyHasImplicitHelpCommand()) {\n      commandDetails.push([this._helpCommandnameAndArgs, this._helpCommandDescription]);\n    }\n    return commandDetails;\n  };\n\n  /**\n   * Return the largest command length.\n   *\n   * @return {number}\n   * @api private\n   */\n\n  largestCommandLength() {\n    const commands = this.prepareCommands();\n    return commands.reduce((max, command) => {\n      return Math.max(max, command[0].length);\n    }, 0);\n  };\n\n  /**\n   * Return the largest option length.\n   *\n   * @return {number}\n   * @api private\n   */\n\n  largestOptionLength() {\n    const options = [].slice.call(this.options);\n    options.push({\n      flags: this._helpFlags\n    });\n\n    return options.reduce((max, option) => {\n      return Math.max(max, option.flags.length);\n    }, 0);\n  };\n\n  /**\n   * Return the largest arg length.\n   *\n   * @return {number}\n   * @api private\n   */\n\n  largestArgLength() {\n    return this._args.reduce((max, arg) => {\n      return Math.max(max, arg.name.length);\n    }, 0);\n  };\n\n  /**\n   * Return the pad width.\n   *\n   * @return {number}\n   * @api private\n   */\n\n  padWidth() {\n    let width = this.largestOptionLength();\n    if (this._argsDescription && this._args.length) {\n      if (this.largestArgLength() > width) {\n        width = this.largestArgLength();\n      }\n    }\n\n    if (this.commands && this.commands.length) {\n      if (this.largestCommandLength() > width) {\n        width = this.largestCommandLength();\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Return help for options.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  optionHelp() {\n    const width = this.padWidth();\n    const columns = process.stdout.columns || 80;\n    const descriptionWidth = columns - width - 4;\n    function padOptionDetails(flags, description) {\n      return pad(flags, width) + '  ' + optionalWrap(description, descriptionWidth, width + 2);\n    };\n\n    // Explicit options (including version)\n    const help = this.options.map((option) => {\n      const fullDesc = option.description +\n        ((!option.negate && option.defaultValue !== undefined) ? ' (default: ' + JSON.stringify(option.defaultValue) + ')' : '');\n      return padOptionDetails(option.flags, fullDesc);\n    });\n\n    // Implicit help\n    const showShortHelpFlag = this._hasHelpOption && this._helpShortFlag && !this._findOption(this._helpShortFlag);\n    const showLongHelpFlag = this._hasHelpOption && !this._findOption(this._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpFlags = this._helpFlags;\n      if (!showShortHelpFlag) {\n        helpFlags = this._helpLongFlag;\n      } else if (!showLongHelpFlag) {\n        helpFlags = this._helpShortFlag;\n      }\n      help.push(padOptionDetails(helpFlags, this._helpDescription));\n    }\n\n    return help.join('\\n');\n  };\n\n  /**\n   * Return command help documentation.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  commandHelp() {\n    if (!this.commands.length && !this._lazyHasImplicitHelpCommand()) return '';\n\n    const commands = this.prepareCommands();\n    const width = this.padWidth();\n\n    const columns = process.stdout.columns || 80;\n    const descriptionWidth = columns - width - 4;\n\n    return [\n      'Commands:',\n      commands.map((cmd) => {\n        const desc = cmd[1] ? '  ' + cmd[1] : '';\n        return (desc ? pad(cmd[0], width) : cmd[0]) + optionalWrap(desc, descriptionWidth, width + 2);\n      }).join('\\n').replace(/^/gm, '  '),\n      ''\n    ].join('\\n');\n  };\n\n  /**\n   * Return program help documentation.\n   *\n   * @return {string}\n   * @api public\n   */\n\n  helpInformation() {\n    let desc = [];\n    if (this._description) {\n      desc = [\n        this._description,\n        ''\n      ];\n\n      const argsDescription = this._argsDescription;\n      if (argsDescription && this._args.length) {\n        const width = this.padWidth();\n        const columns = process.stdout.columns || 80;\n        const descriptionWidth = columns - width - 5;\n        desc.push('Arguments:');\n        desc.push('');\n        this._args.forEach((arg) => {\n          desc.push('  ' + pad(arg.name, width) + '  ' + wrap(argsDescription[arg.name] || '', descriptionWidth, width + 4));\n        });\n        desc.push('');\n      }\n    }\n\n    let cmdName = this._name;\n    if (this._aliases[0]) {\n      cmdName = cmdName + '|' + this._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    const usage = [\n      'Usage: ' + parentCmdNames + cmdName + ' ' + this.usage(),\n      ''\n    ];\n\n    let cmds = [];\n    const commandHelp = this.commandHelp();\n    if (commandHelp) cmds = [commandHelp];\n\n    let options = [];\n    if (this._hasHelpOption || this.options.length > 0) {\n      options = [\n        'Options:',\n        '' + this.optionHelp().replace(/^/gm, '  '),\n        ''\n      ];\n    }\n\n    return usage\n      .concat(desc)\n      .concat(options)\n      .concat(cmds)\n      .join('\\n');\n  };\n\n  /**\n   * Output help information for this command.\n   *\n   * When listener(s) are available for the helpLongFlag\n   * those callbacks are invoked.\n   *\n   * @api public\n   */\n\n  outputHelp(cb) {\n    if (!cb) {\n      cb = (passthru) => {\n        return passthru;\n      };\n    }\n    const cbOutput = cb(this.helpInformation());\n    if (typeof cbOutput !== 'string' && !Buffer.isBuffer(cbOutput)) {\n      throw new Error('outputHelp callback must return a string or a Buffer');\n    }\n    process.stdout.write(cbOutput);\n    this.emit(this._helpLongFlag);\n  };\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   * @api public\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = _parseOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  };\n\n  /**\n   * Output help information and exit.\n   *\n   * @param {Function} [cb]\n   * @api public\n   */\n\n  help(cb) {\n    this.outputHelp(cb);\n    // exitCode: preserving original behaviour which was calling process.exit()\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(process.exitCode || 0, 'commander.help', '(outputHelp)');\n  };\n\n  /**\n   * Output help information and exit. Display for error situations.\n   *\n   * @api private\n   */\n\n  _helpAndError() {\n    this.outputHelp();\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(1, 'commander.help', '(outputHelp)');\n  };\n};\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n\n/**\n * Expose classes\n */\n\nexports.Command = Command;\nexports.Option = Option;\nexports.CommanderError = CommanderError;\n\n/**\n * Camel-case the given `flag`\n *\n * @param {string} flag\n * @return {string}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Pad `str` to `width`.\n *\n * @param {string} str\n * @param {number} width\n * @return {string}\n * @api private\n */\n\nfunction pad(str, width) {\n  const len = Math.max(0, width - str.length);\n  return str + Array(len + 1).join(' ');\n}\n\n/**\n * Wraps the given string with line breaks at the specified width while breaking\n * words and indenting every but the first line on the left.\n *\n * @param {string} str\n * @param {number} width\n * @param {number} indent\n * @return {string}\n * @api private\n */\nfunction wrap(str, width, indent) {\n  const regex = new RegExp('.{1,' + (width - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n  const lines = str.match(regex) || [];\n  return lines.map((line, i) => {\n    if (line.slice(-1) === '\\n') {\n      line = line.slice(0, line.length - 1);\n    }\n    return ((i > 0 && indent) ? Array(indent + 1).join(' ') : '') + line.trimRight();\n  }).join('\\n');\n}\n\n/**\n * Optionally wrap the given str to a max width of width characters per line\n * while indenting with indent spaces. Do not wrap if insufficient width or\n * string is manually formatted.\n *\n * @param {string} str\n * @param {number} width\n * @param {number} indent\n * @return {string}\n * @api private\n */\nfunction optionalWrap(str, width, indent) {\n  // Detect manually wrapped and indented strings by searching for line breaks\n  // followed by multiple spaces/tabs.\n  if (str.match(/[\\n]\\s+/)) return str;\n  // Do not wrap to narrow columns (or can end up with a word per line).\n  const minWidth = 40;\n  if (width < minWidth) return str;\n\n  return wrap(str, width, indent);\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Object} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\n/**\n * Parse the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction _parseOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/commander/index.js?");

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.App = void 0;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst tagdb_1 = __webpack_require__(/*! ./tagdb */ \"./src/tagdb.ts\");\nconst os = __importStar(__webpack_require__(/*! os */ \"os\"));\nfunction getFullPath(item) {\n    return path_1.default.resolve(item);\n}\nfunction getDbPath() {\n    return path_1.default.join(os.homedir(), \".config\", \"ltag\");\n}\nfunction getDbFile() {\n    return \"ltag.dat\";\n}\nfunction jsonToString(obj) {\n    return JSON.stringify(obj, null, 2);\n}\nclass App {\n    constructor() {\n        this.verbose = false;\n        this.tagDb = new tagdb_1.TagDb(getDbPath(), getDbFile());\n    }\n    setVerbose(verbose) {\n        this.verbose = verbose;\n    }\n    async addTag(item, tagList) {\n        const itemPath = getFullPath(item);\n        if (!fs.existsSync(itemPath)) {\n            console.error(`${item} does not exist`);\n            process.exit(-1);\n        }\n        const itemInfo = fs.lstatSync(itemPath);\n        if (!itemInfo.isDirectory() && !itemInfo.isFile()) {\n            console.error(`Cannot handle this type of item`);\n            process.exit(-2);\n        }\n        let itemType = 'file';\n        if (itemInfo.isDirectory()) {\n            itemType = 'directory';\n        }\n        const existingTags = this.tagDb.addTags(itemPath, itemType, ...tagList);\n        console.log(`Tags on ${item}`);\n        console.log(existingTags);\n    }\n    async showTags(item) {\n        const tagList = this.tagDb.getTagsForItem(getFullPath(item));\n        if (this.verbose) {\n            console.log(jsonToString(tagList));\n        }\n        else {\n            tagList.forEach(i => console.log(i));\n        }\n    }\n    async listTags(filterList) {\n        const tagList = this.tagDb.getTags(filterList);\n        if (this.verbose) {\n            console.log(jsonToString(tagList));\n        }\n        else {\n            Object.keys(tagList).forEach(t => console.log(t));\n        }\n    }\n    async findMatchingTags(tagList, findOpts) {\n        const foundTags = this.tagDb.findMatchingItems(tagList, findOpts);\n        if (!foundTags || foundTags.length == 0) {\n            console.log(`No matches found for tags`);\n        }\n        if (this.verbose) {\n            console.log(`Found matches`);\n            console.log(jsonToString(foundTags));\n        }\n        else {\n            foundTags.forEach(i => console.log(`${i.name}` + (i.itemType == 'file' ? '' : '/')));\n        }\n    }\n    async removeTags(item, tagList) {\n        const remainingTags = this.tagDb.removeTags(getFullPath(item), ...tagList);\n        console.log(`Remaining tags: ${remainingTags}`);\n    }\n}\nexports.App = App;\n\n\n//# sourceURL=webpack:///./src/app.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst commander_1 = __webpack_require__(/*! commander */ \"./node_modules/commander/index.js\");\nconst app = new app_1.App();\nconst program = new commander_1.Command('ltag');\nfunction getArgs(firstArg, restArgs) {\n    const allArgs = [firstArg];\n    if (restArgs) {\n        allArgs.push(...restArgs);\n    }\n    return allArgs;\n}\nprogram.command('add <...tag>')\n    .requiredOption('-i, --item <item>', 'The item to tag')\n    .option('-v, --verbose')\n    .action(async (firstTag, cmdObj, restTagList) => {\n    app.setVerbose(cmdObj.verbose);\n    await app.addTag(cmdObj.item, getArgs(firstTag, restTagList));\n});\nprogram.command('show <item>')\n    .option('-v, --verbose')\n    .action(async (item, cmdObj) => {\n    app.setVerbose(cmdObj.verbose);\n    await app.showTags(item);\n});\nprogram.command('list')\n    .option('-v, --verbose')\n    .option('-f, --filter <filter...>', \"Substring filter of tags\")\n    .action(async (cmdObj) => {\n    app.setVerbose(cmdObj.verbose);\n    await app.listTags(cmdObj.filter);\n});\nprogram.command('find <tag...>')\n    .option('-v, --verbose')\n    .option('-t, --type <type>', 'Search for <file> or <dir>')\n    .option('-d, --dir', 'Search for directories')\n    .option('-s, --substring <text>', 'Item must have substring')\n    .option('-p, --partial', \"Partial (substring) match on tags\")\n    .action(async (firstTag, cmdObj, restTagList) => {\n    if (cmdObj.type) {\n        if (cmdObj.type != 'file' && cmdObj.type != 'dir') {\n            console.error(`Invalid type \"${cmdObj.type}\". Type can either be \"file\" or \"dir\"`);\n            process.exit(-3);\n        }\n        if (cmdObj.type == 'dir') {\n            cmdObj.type = \"directory\";\n        }\n    }\n    app.setVerbose(cmdObj.verbose);\n    const tagsToFind = [firstTag];\n    if (restTagList) {\n        tagsToFind.push(...restTagList);\n    }\n    await app.findMatchingTags(tagsToFind, { tagSubstring: cmdObj.partial, nameSubstring: cmdObj.substring, itemType: cmdObj.type });\n});\nprogram.command('remove <tag...>')\n    .option('-v, --verbose')\n    .requiredOption('-i, --item <item>', 'The item to remove the tags from')\n    .action(async (firstTag, cmdObj, restTagList) => {\n    app.setVerbose(cmdObj.verbose);\n    await app.removeTags(cmdObj.item, getArgs(firstTag, restTagList));\n});\nprogram.parseAsync(process.argv).catch(e => console.log(e));\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/tagdb.ts":
/*!**********************!*\
  !*** ./src/tagdb.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TagDb = void 0;\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst SCHEMA_VERSION = 1;\nclass TagDb {\n    constructor(dbPath, dbFile) {\n        this.data = { version: SCHEMA_VERSION, taggedItems: {} };\n        if (!fs.existsSync(dbPath)) {\n            fs.mkdirSync(dbPath, { recursive: true });\n        }\n        this.dbFullPath = path_1.default.join(dbPath, dbFile);\n        this.load();\n    }\n    addTags(item, itemType, ...newTagList) {\n        let tagsForItem = this.data.taggedItems[item];\n        if (!tagsForItem) {\n            tagsForItem = { name: item, itemType: itemType, tagList: [] };\n            this.data.taggedItems[item] = tagsForItem;\n        }\n        tagsForItem.tagList = [...new Set([...tagsForItem.tagList, ...newTagList])];\n        this.save();\n        return tagsForItem.tagList;\n    }\n    getTagsForItem(item) {\n        let tagsForItem = this.data.taggedItems[item];\n        if (!tagsForItem) {\n            return [];\n        }\n        return tagsForItem.tagList;\n    }\n    getTags(filterList) {\n        const tagList = {};\n        for (let [itemName, taggedItem] of Object.entries(this.data.taggedItems)) {\n            for (let tag of taggedItem.tagList) {\n                if (filterList && filterList.length > 0) {\n                    const tagUpper = tag.toUpperCase();\n                    if (filterList.filter(f => tagUpper.includes(f.toUpperCase())).length == 0) {\n                        continue;\n                    }\n                }\n                let tagUsage = tagList[tag];\n                if (!tagUsage) {\n                    tagUsage = [];\n                    tagList[tag] = tagUsage;\n                }\n                tagUsage.push({ itemName: taggedItem.name, itemType: taggedItem.itemType });\n            }\n        }\n        return tagList;\n    }\n    findMatchingItems(tagsToFind, { itemType, nameSubstring, tagSubstring }) {\n        const matchingItems = [];\n        for (let [itemName, taggedItem] of Object.entries(this.data.taggedItems)) {\n            let allTagsMatched = true;\n            for (let tagToFind of tagsToFind) {\n                if (!taggedItem.tagList.includes(tagToFind)) {\n                    if (tagSubstring) {\n                        if (!taggedItem.tagList.find(i => i.includes(tagToFind))) {\n                            allTagsMatched = false;\n                            break;\n                        }\n                    }\n                    else {\n                        allTagsMatched = false;\n                        break;\n                    }\n                }\n            }\n            let isMatch = allTagsMatched;\n            if (itemType && itemType != taggedItem.itemType) {\n                isMatch = false;\n            }\n            if (nameSubstring) {\n                if (!taggedItem.name.toUpperCase().includes(nameSubstring.toUpperCase())) {\n                    isMatch = false;\n                }\n            }\n            if (isMatch) {\n                matchingItems.push(taggedItem);\n            }\n        }\n        return matchingItems;\n    }\n    removeTags(item, ...tagsToDelete) {\n        let tagsForItem = this.data.taggedItems[item];\n        if (!tagsForItem) {\n            return [];\n        }\n        tagsForItem.tagList = tagsForItem.tagList.filter((i) => !tagsToDelete.includes(i));\n        this.save();\n        return tagsForItem.tagList;\n    }\n    save() {\n        fs.writeFileSync(this.dbFullPath, JSON.stringify(this.data, null, 2));\n    }\n    load() {\n        if (!fs.existsSync(this.dbFullPath)) {\n            this.data = { version: SCHEMA_VERSION, taggedItems: {} };\n            return;\n        }\n        const loadedData = JSON.parse(fs.readFileSync(this.dbFullPath, 'utf8'));\n        if (!loadedData.version || loadedData.version != SCHEMA_VERSION) {\n            throw new Error(`Cannot handle data file of version ${loadedData.version}`);\n        }\n        // Ensure tags are unique as someone might have\n        // edited the physical file\n        const items = loadedData.taggedItems;\n        for (let item of Object.keys(items)) {\n            const taggedItem = items[item];\n            const uniqueTags = new Set([...taggedItem.tagList]);\n            taggedItem.tagList = [...uniqueTags];\n        }\n        this.data = loadedData;\n    }\n}\nexports.TagDb = TagDb;\n\n\n//# sourceURL=webpack:///./src/tagdb.ts?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack:///external_%22child_process%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ })

/******/ })));